## 객체 선언 방식

### 객체지향프로그래밍 (Objective Oriented Programming)
- #### OOP는 프로그래밍을 어떻게 할 것인가, 방법론 중 하나
- #### OOP는 객체를 사용해서 모델링하고 프로그래밍을 더 효율적으로 할 수 있게 만들어 주는 방법론임

- #### 이해하기 쉽도록 비유하면
##### 클래스 = 사물이나 개념 등의 컨셉 (붕어빵 틀)
##### 객체 = 클래스에 맞춰서 만들어진 객체 (붕어빵)
##### 속성 = 객체가 가지는 데이터 (자동차 바퀴 갯수, 승차 인원, 창문 갯수 등..)
##### 메서드(함수) = 객체가 가지는 기능 (라이트 켜기, 가속하기, 감속하기, 트렁크 열기 등..)

- #### `객체선언방식`
	- ##### 리터럴 방식
	- ##### 클래스 방식
	- ##### 생성자 방식 new obj()
	- ##### 함수 방식

### 1. 리터럴 방식

다루는 방식이 앞서 컨테이너 자료형 파트에서 배운 json과 같은 이유는,  json을 다루는 것을 객체 리터럴 방식으로 한 것이기 때문임


```JS
const userInfo = {
	name: "홍길동",
	birth: "2020-10-10",
	getName: function () {
	return this.name
	}
}

console.log(userInfo.name);
```

`this와 화살표 함수`

```JS
const obj = {
  nickname: "하하",
  age: 22,
  say: function () {
    console.log(this);
    console.log(`제 이름은 ${this.nickname}, 나이는 ${this.age}살 입니다.`);
  },
};

obj.say();
```

### 2. 클래스 방식
- #### 다른 객체지향기반 언어에서는 클래스 기반으로 표현함
- #### ES6부터는 자바스크립트도 클래스 방식을 사용할 수 있으며 권장되는 방식이기 때문에 객체 리터럴 방식과 함께 두가지 방식을 모두 익혀두는 것이 좋음

- #### `기본적 클래스 선언, 객체 생성 및 속성 접근`
```JS
class Car {
  constructor() {
    this.wheels = 4;
  }
	
	say() {
	console.log(1);
	}
}

const myCar = new Car();
console.log(myCar);
```

- #### `클래스 상속`
	-   extentds를 사용하여 상속할 수 있음
	-   서브 클래스에서는 super() 메서드를 사용해서 부모 생성자에서 정의된 속성을 가져옮

```JS
class SmallCar extends Car {
  constructor() {
    super();
    this.doors = 2;
  }
}

const mySmallCar = new SmallCar();
console.log(mySmallCar);
```

### 3. Object 생성자 방식

```JS
const dummy = new Object();

dummy.attr = 1;
console.log(dummy); // {attr : 1}
```

### 4. 함수방식

-   함수 방식에서는 속성, 메서드를 추가하고 싶으면 prototype을 사용합니다.
```JS

const Dummy = function (param) {
	this.attr = param; 
}; 
Dummy.prototype.attr2 = 3;
const obj = new Dummy(1);
console.log(obj.attr, obj.attr2);

```